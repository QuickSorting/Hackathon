{
    "nodes": [
        {
            "id": "1",
            "label": "MetaDescriptionGenerator",
            "additionalInfoLong": "**Purpose:** The `MetaDescriptionGenerator` class is designed to analyze a software repository's dependency graph represented in JSON format and generate a high-level description of the repository's purpose and structure. It utilizes an OpenAI chat client to formulate a cohesive overview by examining the functionalities of the classes, their interconnections, and the overall architecture, ultimately providing a concise summary that encapsulates the repository's main responsibilities.",
            "additionalInfoShort": "Generates repository purpose and structure summaries from dependency graphs.",
            "source": "class MetaDescriptionGenerator:\n\n    def __init__(self, formatted_output, api_key):\n        chat_client = OpenAIChatClient(api_key)\n        prompt = \"You are an expert in analyzing software repositories. Below is a JSON representation of a dependency graph between classes in a Git repository. The JSON consists of:\\n\\nNodes: Representing classes, each with an id, label (class name), and additionalInfo (which contains a description of the class).\\nEdges: Representing dependencies between classes, where source depends on target.\\nYour task is to generate a high-level, cohesive description of the repository based on:\\n\\nThe functionality and purpose of each class (from additionalInfo).\\nHow the classes are interconnected (from edges).\\nThe overall structure and architecture of the project based on these dependencies.\\nThe main responsibilities of the repository as a whole.\\nHere is the JSON data:\\n\\nCopy\\nEdit\\n\\n{}\\n\\nInstructions:\\n\\nGive a brief summary of the repository's purpose, not specifics, just textual overview - max 1 paragraph, max 80 words!\"\n        prompt = prompt.format(json.dumps(formatted_output, indent=2))\n        self.response = chat_client.get_completion(prompt)\n\n    def save(self, filename):\n        with open(filename, 'w') as f:\n            f.write(self.response)",
            "hidden": false
        },
        {
            "id": "2",
            "label": "RepoParser",
            "additionalInfoLong": "**Purpose:** The `RepoParser` class is designed to analyze a Python repository by parsing its code files to map class and function associations, and to determine class dependencies based on method calls. It loads the repository path, handles `.gitignore` exclusions, and employs two distinct scans to gather the relationships between classes and their methods, ultimately generating a comprehensive output detailing these class connections and their source code along with descriptions obtained via a client interaction with an external API.",
            "additionalInfoShort": "RepoParser analyzes Python repositories for class and function relationships.",
            "source": "class RepoParser:\n\n    def __init__(self, repo_path):\n        self.repo_path = os.path.abspath(repo_path)\n        self.ignore_prefixes = self.load_gitignore_prefixes()\n        self.function_to_class = {}\n        self.class_source_code = {}\n        self.class_dependencies = {}\n\n    def construct_class_dependencies(self):\n        file_path = './key'\n        try:\n            with open(file_path, 'r') as file:\n                api_key = file.read().strip()\n                if not api_key:\n                    raise ValueError('API key is empty.')\n        except FileNotFoundError:\n            raise FileNotFoundError(f\"The key file '{file_path}' does not exist.\")\n        except IOError as e:\n            raise IOError(f'An error occurred while reading the key file: {e}')\n        client = OpenAIChatClient(api_key=api_key)\n        self.parse()\n        classes = {}\n        for cls, deps in self.class_dependencies.items():\n            classes[cls] = (client.generate_class_description(self.class_source_code[cls]), self.class_source_code[cls], list(deps))\n        return classes\n\n    def load_gitignore_prefixes(self):\n        \"\"\"\n        Loads .gitignore and returns a list of normalized absolute path prefixes.\n        Only simple prefixes are supported.\n\n        \"\"\"\n        prefixes = []\n        gitignore_path = os.path.join(self.repo_path, '.gitignore')\n        try:\n            with open(gitignore_path, 'r') as f:\n                for line in f:\n                    line = line.strip()\n                    if line and (not line.startswith('#')):\n                        prefix = os.path.normpath(os.path.join(self.repo_path, line))\n                        prefixes.append(prefix)\n        except FileNotFoundError:\n            print(f'.gitignore not found in {self.repo_path}; proceeding without ignore prefixes.')\n        return prefixes\n\n    def should_ignore(self, path):\n        \"\"\"\n        Check if the given path should be ignored based on the .gitignore prefixes.\n        \"\"\"\n        normalized = os.path.normpath(path)\n        return any((normalized.startswith(prefix) for prefix in self.ignore_prefixes))\n\n    def get_py_files(self):\n        \"\"\"Generator yielding Python file paths under the repository that are not ignored.\"\"\"\n        for root, dirs, files in os.walk(self.repo_path, topdown=True):\n            dirs[:] = [d for d in dirs if not self.should_ignore(os.path.join(root, d))]\n            for file in files:\n                filepath = os.path.join(root, file)\n                if file.endswith('.py') and (not self.should_ignore(filepath)):\n                    yield filepath\n\n    def parse(self):\n        \"\"\"\n        Runs the two scans:\n         1. Collects mapping of function names to their classes.\n         2. Analyzes dependencies based on function calls.\n        \"\"\"\n        for filepath in self.get_py_files():\n            self.parse_functions(filepath)\n        for filepath in self.get_py_files():\n            deps = self.analyze_dependencies(filepath)\n            for cls, dep_set in deps.items():\n                if cls not in self.class_dependencies:\n                    self.class_dependencies[cls] = set()\n                self.class_dependencies[cls].update(dep_set)\n\n    def parse_functions(self, filepath):\n        \"\"\"\n        First scan: parse file to map each function (method) name to its class.\n        \"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                content = f.read()\n            tree = ast.parse(content, filename=filepath)\n            visitor = ClassFunctionVisitor()\n            visitor.visit(tree)\n            self.function_to_class.update(visitor.function_to_class)\n            self.class_source_code.update(visitor.class_source_code)\n        except Exception as e:\n            print(f'Error parsing functions in {filepath}: {e}')\n\n    def analyze_dependencies(self, filepath):\n        \"\"\"\n        Second scan: parse file to detect dependencies between classes based on method calls.\n        Returns a dict: { caller_class: set(dependent_class) }\n        \"\"\"\n        deps = {}\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                content = f.read()\n                tree = ast.parse(content, filename=filepath)\n            visitor = DependencyVisitor(self.function_to_class)\n            visitor.visit(tree)\n            deps = visitor.dependencies\n        except Exception as e:\n            print(f'Error analyzing dependencies in {filepath}: {e}')\n        return deps",
            "hidden": false
        },
        {
            "id": "3",
            "label": "ClassFunctionVisitor",
            "additionalInfoLong": "**Purpose:** The `ClassFunctionVisitor` is a custom AST (Abstract Syntax Tree) visitor designed to traverse Python class definitions within a source code tree. Its primary responsibility is to map method names to their corresponding class names, thereby creating a dictionary that associates each method defined in a class with the class itself. This class also captures the source code representation of each class for potentially further analysis, assuming that method names are unique throughout the entire codebase.",
            "additionalInfoShort": "ClassFunctionVisitor maps method names to their class definitions.",
            "source": "class ClassFunctionVisitor(ast.NodeVisitor):\n    \"\"\"\n    First-pass visitor: records for each class the methods it defines.\n    Builds a mapping: function (method) name -> class name.\n    Assumes function names are unique across all classes.\n    \"\"\"\n\n    def __init__(self):\n        self.function_to_class = {}\n        self.class_source_code = {}\n\n    def visit_ClassDef(self, node):\n        class_name = node.name\n        self.class_source_code[class_name] = ast.unparse(node)\n        for item in node.body:\n            if isinstance(item, ast.FunctionDef):\n                self.function_to_class[item.name] = class_name\n        self.generic_visit(node)",
            "hidden": false
        },
        {
            "id": "4",
            "label": "DependencyVisitor",
            "additionalInfoLong": "**Purpose:** The `DependencyVisitor` class is designed to analyze the abstract syntax tree (AST) of Python code, specifically focusing on class methods within those classes. It utilizes a provided mapping of functions to their corresponding classes to determine inter-class dependencies based on function calls. By doing so, it constructs a dictionary that tracks which classes depend on each other, thereby enabling better understanding and management of dependencies in the codebase.",
            "additionalInfoShort": "DependencyVisitor analyzes class method dependencies in Python's AST.",
            "source": "class DependencyVisitor(ast.NodeVisitor):\n    \"\"\"\n    Second-pass visitor: examines function calls within class methods and determines\n    dependencies based on the function_to_class mapping from the first scan.\n    \"\"\"\n\n    def __init__(self, function_to_class):\n        self.function_to_class = function_to_class\n        self.dependencies = {}\n        self.current_class = None\n        self.current_class_source = None\n\n    def visit_ClassDef(self, node):\n        self.current_class = node.name\n        self.current_class_source = ast.unparse(node)\n        self.dependencies.setdefault(self.current_class, set())\n        self.generic_visit(node)\n\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n            if func_name in self.function_to_class and self.current_class:\n                callee_class = self.function_to_class[func_name]\n                if self.current_class != callee_class:\n                    self.dependencies[self.current_class].add(callee_class)\n        elif isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name):\n            method_name = node.func.attr\n            if method_name in self.function_to_class:\n                callee_class = self.function_to_class[method_name]\n                if self.current_class and self.current_class != callee_class:\n                    self.dependencies[self.current_class].add(callee_class)\n        self.generic_visit(node)",
            "hidden": false
        },
        {
            "id": "5",
            "label": "OpenAIChatClient",
            "additionalInfoLong": "**Purpose:** The `OpenAIChatClient` class is designed to facilitate communication with the OpenAI API, allowing users to send input and receive chat completions, specifically utilizing the GPT-4o-mini model. It initializes the client with an API key, handles the interaction with the API through the `get_completion` method to retrieve AI-generated responses based on user input, and includes another method, `generate_class_description`, which utilizes the API to generate explanations and summaries of code classes. This class effectively encapsulates the functionality required to leverage AI-based chat capabilities in applications.",
            "additionalInfoShort": "The OpenAIChatClient enables interaction with OpenAI's GPT-4o-mini.",
            "source": "class OpenAIChatClient:\n\n    def __init__(self, api_key):\n        \"\"\"\n        Initializes the OpenAI client with the provided API key.\n        \"\"\"\n        self.client = openai.OpenAI(api_key=api_key)\n\n    def get_completion(self, user_input):\n        \"\"\"\n        Sends a chat completion request to the OpenAI API based on the user input\n        and returns the completion as a string.\n        \"\"\"\n        try:\n            response = self.client.chat.completions.create(model='gpt-4o-mini', messages=[{'role': 'system', 'content': 'You are a helpful assistant.'}, {'role': 'user', 'content': user_input}])\n            return response.choices[0].message.content\n        except Exception as e:\n            return f'An error occurred: {str(e)}'\n\n    def generate_class_description(self, source):\n        template_long = '\\n        You are an expert software engineer and technical writer. Below is the code for a class from a software repository written in Python. Please provide a detailed description of this class in the following format:\\n\\n        **Purpose:** What is the main responsibility of this class? (I want just a single paragraph)\\n\\n        [Insert class code here]\\n        '\n        prompt = template_long.replace('[Insert class code here]', source)\n        long = self.get_completion(prompt)\n        if long is None:\n            return ('', '')\n        template_short = '\\n        Can you summarize this in one sentence upto 10 words without markdown\\n        [Insert string here]\\n        '\n        prompt = template_short.replace('[Insert string here]', long)\n        short = self.get_completion(prompt)\n        return (short, long)",
            "hidden": false
        },
        {
            "id": "6",
            "label": "Main",
            "additionalInfoLong": "**Purpose:** The `Main` class serves as a central orchestrator for reading an API key from a file, parsing class dependencies from a given repository, reformatting these dependencies into a structured output, and generating a meta description based on that output\u2014all while managing file I/O operations for saving results to JSON and text formats.",
            "additionalInfoShort": "The Main class orchestrates API key handling and dependency output.",
            "source": "class Main:\n\n    def main(self):\n        file_path = './key'\n        with open(file_path, 'r') as file:\n            api_key = file.read().strip()\n            if not api_key:\n                raise ValueError('API key is empty.')\n        repo = RepoParser('./')\n        classes = repo.construct_class_dependencies()\n        diagram_parser = OutputReformatter(classes)\n        formatted_output = diagram_parser.generate_structure()\n        diagram_parser.save_to_json('formatted_output.json')\n        meta_description_generation = MetaDescriptionGenerator(formatted_output, api_key)\n        meta_description_generation.save('meta_description.txt')",
            "hidden": false
        },
        {
            "id": "7",
            "label": "OutputReformatter",
            "additionalInfoLong": "**Purpose:** The `OutputReformatter` class is designed to process a given dictionary that maps class names to their descriptions and dependencies, transforming this information into a structured format that represents nodes and edges for graph-based visualization. It facilitates the generation of nodes representing classes and edges indicating dependencies between them, providing methods to output this structured data and save it in JSON format for further use or visualization in graphical tools.",
            "additionalInfoShort": "The OutputReformatter class structures class data for graph visualization.",
            "source": "class OutputReformatter:\n\n    def __init__(self, class_dict):\n        \"\"\"\n        Initialize the Reformatter with a dictionary in the format:\n        {'class name': [class_description: str, dependent_classes: list[str]]}\n        \"\"\"\n        self.class_dict = class_dict\n        self.nodes = []\n        self.edges = []\n        self.node_ids = {}\n\n    def generate_structure(self):\n        \"\"\"Generates the nodes and edges structure.\"\"\"\n        counter = 1\n        print(self.class_dict.items())\n        for class_name, ((short, long), source, _) in self.class_dict.items():\n            node_id = str(counter)\n            self.node_ids[class_name] = node_id\n            self.nodes.append({'id': node_id, 'label': class_name, 'additionalInfoLong': long, 'additionalInfoShort': short, 'source': source, 'hidden': False})\n            counter += 1\n        edge_counter = 1\n        for class_name, (_, _, dependencies) in self.class_dict.items():\n            source_id = self.node_ids[class_name]\n            for dep in dependencies:\n                if dep in self.node_ids:\n                    target_id = self.node_ids[dep]\n                    self.edges.append({'id': f'e{edge_counter}', 'source': source_id, 'target': target_id})\n                    edge_counter += 1\n\n    def get_output(self):\n        \"\"\"Returns the structured dictionary output.\"\"\"\n        return {'nodes': self.nodes, 'edges': self.edges}\n\n    def save_to_json(self, filename='output.json'):\n        \"\"\"Saves the structured data to a JSON file.\"\"\"\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(self.get_output(), f, indent=4)\n        print(f'JSON saved as {filename}')",
            "hidden": false
        }
    ],
    "edges": [
        {
            "id": "e1",
            "source": "1",
            "target": "5"
        },
        {
            "id": "e2",
            "source": "2",
            "target": "5"
        },
        {
            "id": "e3",
            "source": "6",
            "target": "7"
        },
        {
            "id": "e4",
            "source": "6",
            "target": "2"
        },
        {
            "id": "e5",
            "source": "6",
            "target": "1"
        }
    ]
}